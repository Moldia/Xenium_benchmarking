import numpy as np
from numpy import ndarray
import anndata as ad
from anndata import AnnData
import pandas as pd
from pandas import DataFrame
import scanpy as sc
from typing import Optional


def run_majority_voting(
    adata_st: AnnData,
    spots: pd.DataFrame
) -> AnnData:

    """Add cell type annotation by majority voting of available annotations listed in ``spots['celltype']``
    Parameters
    ----------
    adata_st : AnnData
        File name of CSV containing genes and cell assignments
    spots : pd.DataFrame
        File name containing cell type for each cell, by default None
        
    Returns
    -------
    AnnData
        Anndata object with cell type annotation in ``adata_st.obs['ct_majority']`` and certainty as ``adata_st.obs['ct_majority_cert']`` 
    """

    for cell_id in adata_st.obs['cell_id']:
        cts = spots[spots['cell'] == cell_id ]['Gene'].value_counts()
        
        if 'celltype' in spots.columns:
            mode = spots[spots['cell'] == cell_id ]['celltype'].mode()
            adata_st.obs.loc[adata_st.obs['cell_id'] == cell_id, 'ct_majority'] = mode.values[0]
            adata_st.obs.loc[adata_st.obs['cell_id'] == cell_id, 'ct_majority_cert'] = (spots[spots['cell'] == cell_id ]['celltype'].value_counts()[mode].values[0] / sum(cts))
            
        else:
            print('No celltypes available in spots object')

    return adata_st


def generate_adata(
    molecules: str,
    ct_method: str,
    ct_certainty_threshold: float = 0.7,
    adata_sc: Optional[str] = None,
    ct_assign_output: Optional[str] = None,
    all_ct_methods: bool = False,
    prior_pct: float = 0.5
) -> AnnData:
    """Generate an AnnData object with counts from molecule data and assign cell types
    Parameters
    ----------
    molecules : str
        File name of CSV containing genes and cell assignments
    ct_method : str
        Method to use for cell type annotation. Output will be added to ``adata.obs['ct_<ct_method>']`` and duplicated in  ``adata.obs['celltype']``. Valid entries are ``['majority', 'ssam', 'pciSeq']``
    ct_certainty_threshold : Optional[float]
        To be set if ``ct_method`` provides a certainty measure of the cell type assignment. Threshold will be applied when annotations are set as ``adata.obs['celltype']`` to keep all annotations in ``adata.obs['ct_<ct_method>']``. For ``ct_method=='majority'`` the certainty refers to the percent of spots per cell assigned to a celltype proir to segmentatation, for ``ct_method=='ssam'`` it refers to **TODO!**
    ct_assign_output : Optional[str]
        File name containing cell type for each cell generated by the spot to cell assignment method, currently only implemented for pciSeq, default is ``'None'``
    all_ct_methods : Optional[bool]
        If set to True, all available cell type annotation methods are ran, results added as ``adata.obs['ct_<ct_method>']`` and the method chosen as ct_method is duplicated to ``adata.obs['celltype']``
    Returns
    -------
    AnnData
        Populated count matrix
    """    
    
    #Read assignments, calculate percentage of non-assigned spots (pct_noise) and save raw version of spots
    spots = pd.read_csv(molecules) 
    pct_noise = sum(spots['cell'] <= 0)/len(spots['cell'])
    spots_raw = spots.copy() # save raw spots to add to adata.uns and set 0 to None
    spots_raw.loc[spots_raw['cell']==0,'cell'] = None
    spots = spots[spots['cell'] > 0]

    #Generate blank, labelled count matrix
    X = np.zeros([ len(pd.unique(spots['cell'])), len(pd.unique(spots['Gene'])) ])
    adata = ad.AnnData(X, dtype = X.dtype)
    adata.obs['cell_id'] = pd.unique(spots['cell'])
    adata.obs_names = [f"Cell_{i:d}" for i in range(adata.n_obs)]
    adata.var_names = pd.unique(spots['Gene'])
    
    #Populate matrix using assignments
    for cell_id in adata.obs['cell_id']:
        cts = spots[spots['cell'] == cell_id ]['Gene'].value_counts()
        adata[adata.obs['cell_id'] == cell_id, :] = cts.reindex(adata.var_names, fill_value = 0)
    
    #Add celltype according to ct_method and check if all methods should be implemented
    if (ct_method == 'None'): ct_method = 'majority'
    if (ct_method == 'majority' or all_ct_methods):
        adata = run_majority_voting(adata, spots)
    else:
        print('No valid cell type annotation method')
    
    # Take over primary ct annotation method to adata.obs['celltype'] and apply certainty threshold
    # Add methods, if they provide certainty measure
    if ct_method in ['majority']: 
        ct_list = adata.obs['ct_'+str(ct_method)].copy()
        ct_list[adata.obs['ct_'+str(ct_method)+'_cert'] < ct_certainty_threshold] = "Unknown"
        adata.obs['celltype'] = ct_list
    else:
        adata.obs['celltype'] = adata.obs['ct_'+str(ct_method)]

    #Save additional information about the data
    adata.uns['spots'] = spots_raw
    adata.uns['pct_noise'] = pct_noise
    adata.layers['raw_counts'] = adata.X.copy()

    #Calculate some basic statistics
    adata.obs['n_counts']= np.sum(adata.layers['raw_counts'], axis = 1)
    adata.obs['n_genes']= np.sum(adata.layers['raw_counts']>0, axis = 1)
    adata.var['n_counts']= np.sum(adata.layers['raw_counts'], axis=0)
    adata.var['n_cells']= np.sum(adata.layers['raw_counts']>0, axis = 0)

    return adata



def normalize_by_area(
    adata: AnnData,
    area: Optional[str] = 'area',
    inplace: Optional[bool] = True
) -> Optional[np.ndarray]:
    """Normalize counts by area of cells
    Parameters
    ----------
    adata : AnnData
        The annotated data matrix of shape `n_obs` x `n_vars`.
        Rows correspond to cells and columns to genes.
    area : Optional[str], optional
        Name of the field in `adata.obs` where the area is
        stored, by default 'area'
    inplace : Optional[bool], optional
        If ``True``, update ``adata`` with results. Otherwise, return results, by default True
    Returns
    -------
    np.ndarray
        If ``inplace=True``, ``adata.X`` is updated with the normalized values. 
        Otherwise, returns normalized numpy array
    """
    x = adata.X / adata.obs[area].to_numpy()[:,None]
    
    if(not inplace):
        return x
    adata.layers['raw'] = adata.X.copy()
    adata.layers['norm'] = x
    adata.layers['lognorm'] = adata.layers['norm'].copy()
    sc.pp.log1p(adata, layer='lognorm')
  
    return adata


def calculate_alpha_area(
    adata: AnnData,
    alpha: float = 0
) -> ndarray:
    """Calculate and store the alpha shape area of the cell given a set of points (genes). 
    Uses the Alpha Shape Toolboox: https://alphashape.readthedocs.io/en/latest/readme.html 
    Parameters
    ----------
    adata : AnnData
        AnnData object with cells as `obs` and genes as `var`, and spots as `adata.uns['spots']`
    alpha : float, optional
        The alpha parameter a, used to calculate the alpha shape, by default 0. If -1, optimal alpha 
        parameter will be calculated.
    Returns
    -------
    ndarray
        Returns the area vector stored in `adata.obs['alpha_area']` as a numpy array
    """    

    import alphashape
    from descartes import PolygonPatch
    import shapely
    import json
    
    #Read assignments
    spots = adata.uns['spots']

    # Calculate alpha shape
    # If there are <3 molecules for a cell, use the mean area
    area_vec = np.zeros([adata.n_obs])
    shape_vec = []
    for i in range(adata.n_obs):
        dots = pd.concat(
            [spots[spots['cell'] == adata.obs['cell_id'][i]].x,
            spots[spots['cell'] == adata.obs['cell_id'][i]].y],
            axis=1
        )
        pts = list(dots.itertuples(index=False, name=None))
        #If alpha is negative, find optimal alpha, else use parameter/convex hull
        if alpha < 0 and len(pts) > 3:
            opt_alpha = alphashape.optimizealpha(pts, max_iterations=100, lower = 0, upper = 10, silent=False)
            alpha_shape = alphashape.alphashape(pts, opt_alpha)
        elif alpha < 0:
            alpha_shape = alphashape.alphashape(pts,0)
        else:    
            alpha_shape = alphashape.alphashape(pts,alpha)
        
        shape_vec.append(json.dumps(shapely.geometry.mapping(alpha_shape)))
        #If possible, take area of alpha shape
        if(len(pts) > 3):
            area_vec[i] = alpha_shape.area
        else:
            area_vec[i] = np.nan
    
    #Find mean cell area and fill in NaN and very small values
    mean_area = np.nanmean(area_vec)
    area_vec[np.isnan(area_vec)] = mean_area
    area_vec[np.where(area_vec < 1)] = mean_area

    adata.obs['alpha_area'] = area_vec
    adata.obs['alpha_shape'] = shape_vec
    return area_vec